# 01. Ausgewählte Prinzipien der Rechnerarchitektur

Rechnerarchitektur = Wissenschaft der Grundlagen zum Entwurf von ComputerHardware

### <ins>Software-Seite:</ins>

* Fülle von Andwendungsfeldern mit unterschiedlichen Anforderungen 
* Software-Entwicklung vergleichsweise langsam 
* hohe Flexibilität 
* Hoher Bedarf an neuen Funktionalitäten 
* Wunsch nach hoher Performance  +
* ->insgesamt aber langsame zeitliche Entwicklung mit größerer Heterogenität 

----
Abstraktion: Befehl / Instruction Set Architekture (ISA)

### <ins>Hardware-Seite:</ins>

* zwingend hohe Performance, geringer Preis, Wunsch nach "Einfachkeit" Regularität 
* Technologie soll schnell verfügbar sein 
* -> insgesamt etwas schnellere zeitliche Entwicklung mit großer Homogenität in Technologie

----
--Computer führt Befehle aus, die Daten bewegen oder transformieren

### <ins>ISA = Spezifikation einer Menge von Befehlen, die: </ins>

* eine HArdware korrekt implementieren muss
* eine effizente Kontrolle von "Prozessor", Speicher, IO-Geräten erlauben
* eine gewünschte Zielfunktion optimiert 


-Befehlslisten \
-von C-Progamm in  Assembly \
-> Bsp: int x, y, z, / 
        int res = (x+y)-z \
-> in ASS: add x5, x2, x3 /
           sub x6, x5, x4


### <ins>Ausführung von Befehlen:</ins>

* Fetch instruction 
* Decode instruction 
* Fetch operants
* Compute operations 
* Read memory ggf.
* Write memory 
* Update PC

-> längeres Programm induziert eine geordnete Reihenfolge von Befehlen \
-> sequentielle Abstraktion ist richtig und früher wollte man diese an Software-Ebene weiterreichen

### <ins>Beschleunigung von Befehlsausführung:</ins>
-> alle Teilaufgaben benötigen geliche Zeit t 

1. **Minimiert**   
-> vorher: |----|----|----| ( zwischenbereiche sind **t** ) \
-> nacher: |--|--|--| ( Zwischenbereiche sind **t'** ) \
-> somit: t' < t -> dh.: dh nach Minimierung sind ist bereich |--| kleiner (minimiert), als Bereich |----| 

2. **Instructionlevel Parallelism**  
-> gebe Illusion der serielllen Ausführung an Software, aber Parallelität auf Hardware-Ebene \
-> um Parallelität zu schaffen -> Pipelining 

   1. Pipelining  
        -> ohne Pipeline: T(n) = n * k * t \
        -> mit Pipeline: T_k(n) = (k + n - 1) * t \
        -> Speedup S = T(n)/T_k(n) = nkt/(nt + (k-1) t) = k/(1 + ((k-1)/n)) --(n->unednlich)--> k \
        -> k = Tiefe der Pipeline  = #Teilaufgaben

    2. Multiple Issue  
        -> Zeit ---> [Befehl 1] und [Befehl 2] untereinander auf gleicher Spalte | [Befehl 3] und [Befehl 4] drunter untereinander auf gleicher Spalte aber nach rechts verschoben 

   3. Speculative Execution  
        Miniaturisierung: \
        -> die Zeit t für die Ausführung einer Teilaufgabe eines Befehls ist *maßgeblich* verantwortlich für die Ausführungszeit eines (großen) Programms \
        -> Bsp: Sei V Volumen der Sprudelflasche, Befüllen/Entleeren erfolgt jeweils mit Geschwindigkeit 10 l/min \
        -> Wechsel von 0 nach 1: dauert T = (V/10l) min \
        -> Sei V' = (V/alpha) um Faktor alpha > 1 kleiner machen \
        -> Sei T' = (V/ (a * 10l)) min = (1/alpha) * T
        -> FAZIT: Information hat keine natürliche Größe und kann in physikalischer Größe runterskaliert werden 

----
### <ins>Zwischenthema: Camputer/Componenten Ebene (NICHT-Klausurrelevant) </ins>
-> Siehe 01_image_0

### <ins>Zylinderkondensator</ins>
-> Siehe 01_image_1









